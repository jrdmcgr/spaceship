<html>
<head>
	<title>Space!</title>
	<style>
		html, body {
			margin: 0;
			padding: 0;
		}
	</style>
</head>
<body>
<script>

'use strict';

var Entity, Bullet, Dude, avatar, keys, entities, canvas, context;


Entity = function (config) {
	this.height = config.height || 1;
	this.width = config.width || 1;
	this.position = config.position || { x: 0, y: 0 };
	this.rotation = config.rotation || 0;
	this.velocity = config.velocity || { x: 0, y: 0 };
	this.acceleration = config.acceleration || 0;
	this.speed = config.speed || 0;
	this.speedLimit = config.speedLimit || 0;
	this.direction = null;
}

Entity.prototype.update = function () {
	this.draw();
}

Entity.prototype.computeVelocity = function () {
	this.direction = this.rotation;
	// Get the complementary angle.
	var theta = 90 - this.rotation;		
	// Convert to radians.
	theta = theta * Math.PI / 180;
	
	this.velocity.x = this.speed * Math.cos(theta);
	// The canvas is flipped along the x axis, so multiply y by negative 1.
	this.velocity.y = this.speed * Math.sin(theta) * -1;
}


/*============================================================================*/


Bullet = function (config) {
	Entity.call(this, config || {});
	this.height = 3;
	this.width = 3;
	this.speed = config.speed || 0;
	this.acceleration = 0.7;
	this.velocity = { x: 0, y: 0 }
}

Bullet.prototype = Object.create(Entity.prototype)

Bullet.prototype.update = function () {
	this.speed += this.acceleration;
	this.computeVelocity()
	this.position.x += this.velocity.x
	this.position.y += this.velocity.y

	// Destroy the bullet if it is out of bounds.
	if (this.position.x < 0 
	||  this.position.y < 0
	||  this.position.x > canvas.width
	||  this.position.y > canvas.height) {
		entities.remove(this)
	}

	this.draw()
}

Bullet.prototype.draw = function () {
	context.save();
	context.fillStyle = 'red';
	// context.fillRect(this.position.x, this.position.y, this.height, this.width);
	context.beginPath();
	context.arc(
		this.position.x + (this.width / 2), 
		this.position.y + (this.height / 2), 
		this.width / 2, 
		0,
		Math.PI * 2
	);
	context.fill();
	context.closePath();
	context.restore();
}


/*============================================================================*/


Dude = function (config) {
	Entity.call(this, config || {});
	this.idle = false;
	// The direction that dude is turning around to when we press DOWN.
	this.turningTo = null;
	this.isThrusting = false;
	this.newSpeed = 0;
}

Dude.prototype = Object.create(Entity.prototype)

Dude.prototype.draw = function () {
	context.save();
	var oldx = this.position.x
	var oldy = this.position.y
	
	// Rotate the entity around it's center
	var centerx = this.position.x + (this.width / 2);
	var centery = this.position.y + (this.height / 2);
	this.position.x -= centerx;
	this.position.y -= centery;
	context.translate(centerx, centery);
	context.rotate(this.rotation * Math.PI / 180);

	// Draw a triangle.
	context.strokeWidth = 2;
	context.strokeStyle = '000000';
	context.beginPath();
	context.moveTo(this.position.x + (this.width / 2), this.position.y);
	context.lineTo(this.position.x, this.position.y + this.height);
	context.lineTo(this.position.x + this.width, this.position.y + this.height);
	context.lineTo(this.position.x + (this.width / 2), this.position.y);
	context.stroke();
	context.closePath();

	// Draw the fire when thrusting
	if (this.isThrusting) {
		context.strokeWidth = 2;
		context.strokeStyle = '#FF0000';
		context.beginPath();
		context.moveTo(this.position.x + 3, this.position.y + this.height + 2);
		context.lineTo(this.position.x + this.width / 2, this.position.y + this.height + 10);
		context.lineTo(this.position.x + this.width - 3, this.position.y + this.height + 2);
		context.lineTo(this.position.x + 3, this.position.y + this.height + 2);
		context.stroke();
	}
	// XXX: This should be done in keys...
	this.isThrusting = false;

	this.position.x = oldx;
	this.position.y = oldy;
	context.restore();
}

Dude.prototype.update = function () {
	// Decellerate
	if (this.idle && this.speed > 0) {
		this.speed -= 0.1;
	} 
	else if (this.idle && this.speed < 0) {
		this.speed = 0
	}

	// Decellerate
	if (this.idle && this.newSpeed > 0) {
		this.newSpeed -= 0.1;
	} 
	else if (this.idle && this.newSpeed < 0) {
		this.newSpeed = 0
	}


	this.velocity.x = this.speed * Math.sin(this.direction * Math.PI / 180)
	this.velocity.y = this.speed * Math.cos(this.direction * Math.PI / 180) * -1
		
	this.position.x += this.velocity.x;
	this.position.y += this.velocity.y;

	// Teleport at map edges
	if (this.position.x < this.width * -1)
		this.position.x = canvas.width + this.width
	else if (this.position.x > canvas.width + this.width)
		this.position.x = this.width * -1

	if (this.position.y < this.width * -1)
		this.position.y = canvas.height + this.width
	else if (this.position.y > canvas.height + this.width)
		this.position.y = this.width * -1

	this.draw();
}

Dude.prototype.forward = function () {
	
	this.isThrusting = true;

	function computeVelocity(direction, speed) {
		// Get the complementary angle.
		var theta = 90 - direction;		
		// Convert to radians.
		theta = theta * Math.PI / 180;
		var vx = speed * Math.cos(theta);
		// The canvas is flipped along the x axis, so multiply y by negative 1.
		var vy = speed * Math.sin(theta) * -1;
		return {x: vx, y: vy}
	}

	// Accelerate
	if (this.speed < this.speedLimit)
		this.speed += this.acceleration

	// I need to somehow slowly convert the current velocity to the desired
	// velocity, instead of changing it immediately.

	this.newSpeed += this.acceleration;
	this.currentVelocity = computeVelocity(this.direction, this.speed)
	this.desiredVelocity = computeVelocity(this.rotation, this.newSpeed)

	this.velocity = {
		x: (this.currentVelocity.x + this.desiredVelocity.x) / 2,
		y: (this.currentVelocity.y + this.desiredVelocity.y) / 2
	}

	this.direction = this.rotation//(Math.atan2(this.velocity.y / this.velocity.x) * 180 / Math.PI) + 90
}

Dude.prototype.backward = function () {
	// Rotate around to the opposite direction.
	if (this.turningTo === null) {
		this.turningTo = this.rotation + 180;
		if (this.turningTo > 360)
			this.turningTo -= 360;
	}		


	if (this.rotation < this.turningTo) {
		this.rotation += 10;
	} else if (this.rotation > this.turningTo) {
		this.rotation -= 10;
	}
	
}

Dude.prototype.fire = function () {
	var centerx = this.position.x + (this.width / 2);
	var centery = this.position.y + (this.height / 2);
	entities.add(new Bullet({
		position: { x: centerx, y: centery },
		rotation: this.rotation,
		speed: this.speed + 5
	}));
}


/*============================================================================*/

// XXX: put all of this stuff in a game object, with an init method.

canvas = document.createElement('canvas');
// canvas.style.borderStyle = 'solid';
canvas.height = innerHeight;
canvas.width = innerWidth;
context = canvas.getContext('2d');

avatar = new Dude({
	height: 20,
	width: 20,
	position: { 
		x: canvas.width / 2, 
		y: canvas.height / 2 
	},
	speed: 0,
	speedLimit: 10,
	acceleration: 0.5,
})

keys = {
	LEFT:  37,
	UP:    38,
	RIGHT: 39,
	DOWN:  40,
	SPACE: 32,

	// This array holds the key codes that are currently depressed.
	// This is so that we can process this array and perform more than one
	// movement per tick.
	pressed: [],
	
	add: function (key) {
		if (this.pressed.indexOf(key) == -1)
			this.pressed.push(key);
	},
	remove: function (key) {
		this.pressed = this.pressed.filter(function (k) {
			return k != key;
		});
	},
	dispatch: function () {
		for (var key in this.pressed) {
			switch (this.pressed[key]) {
				case this.LEFT:
					// XXX: this logic should be in a method on Dude.
					avatar.rotation -= 5;
					if (avatar.rotation < 0)
						avatar.rotation = 360 - 5;
					break;
				case this.RIGHT:
					avatar.rotation += 5;
					if (avatar.rotation === 360)
						avatar.rotation = 0;
					break;
				case this.UP:
					avatar.forward();
					break;
				case this.DOWN:
					avatar.backward();
					break;
				case this.SPACE:
					avatar.fire();
					break;
			}
		}
		// If UP is not in the pressed array, then set idle to true.
		avatar.idle = this.pressed.indexOf(this.UP) == -1 ? true : false;		

		if (this.pressed.indexOf(this.DOWN) == -1) {
			avatar.turningTo = null;
		}
	}
}

entities = {
	visible: [],
	add: function (entity) {
		if (this.visible.indexOf(entity) == -1)
			this.visible.push(entity);
	},
	remove: function (entity) {
		this.visible = this.visible.filter(function (e) {
			return e != entity;
		});
	},
	update: function () {
		this.visible.forEach(function (entity) {
			entity.update()
		});
	}
}

function clear() {
	// Clear the entire canvas
	context.clearRect(0, 0, canvas.width, canvas.height);
}

function tick() {
	clear();
	keys.dispatch();
	entities.update()
	avatar.update();
}


document.body.appendChild(canvas);
document.addEventListener('keydown', function (e) { keys.add(e.which) });
document.addEventListener('keyup', function (e) { keys.remove(e.which) });
setInterval(tick, 30);

</script>
</body>
</html>